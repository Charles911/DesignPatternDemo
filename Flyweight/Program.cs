namespace Flyweight;

/// <summary>
/// 享元模式
/// </summary>
/// <remarks>
/// 享元模式——运用共享技术有效地支持大量细粒度的对象。
/// 享元模式可以避免大量相似类的开销，在软件开发中如果需要生成大量细粒度的类实例来表示数据，如果这些实例除了几个参数外基本上都是相同的，这时候就可以使用享元模式来大幅度减少需要实例化类的数量。
/// 如果能把这些参数（指的这些类实例不同的参数）移动类实例外面，在方法调用时将他们传递进来，这样就可以通过共享大幅度地减少单个实例的数目。（这个也是享元模式的实现要领）,然而我们把类实例外面的参数称为享元对象的外部状态，把在享元对象内部定义称为内部状态。
/// 具体享元对象的内部状态与外部状态的定义为：
/// 内部状态：在享元对象的内部并且不会随着环境的改变而改变的共享部分
/// 外部状态：随环境改变而改变的，不可以共享的状态。
/// 
/// 优点：
/// 1.降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。
/// 
/// 缺点：
/// 1.为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑更复杂，使系统复杂化。
/// 2.享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。
/// 
/// 使用场景：
/// 在下面所有条件都满足时，可以考虑使用享元模式：
/// 1.一个系统中有大量的对象；
/// 2.这些对象耗费大量的内存；
/// 3.这些对象中的状态大部分都可以被外部化；
/// 4.这些对象可以按照内部状态分成很多的组，当把外部对象从对象中剔除时，每一个组都可以仅用一个对象代替；
/// 5.软件系统不依赖这些对象的身份。
/// 满足上面的条件的系统可以使用享元模式。
/// 但是使用享元模式需要额外维护一个记录子系统已有的所有享元的表，而这也需要耗费资源，所以，应当在有足够多的享元实例可共享时才值得使用享元模式。
/// 
/// 附：享元模式主要用来解决由于大量的细粒度对象所造成的内存开销的问题，它在实际的开发中并不常用，可以作为底层的提升性能的一种手段
/// </remarks>
internal class Program
{
    private static void Main(string[] args)
    {
        //定义外部状态，例如字母的位置等信息
        int extrinsicstate = 10;
        //初始化享元工厂
        var factory = new FlyweightFactory();

        var fa = factory.GetFlyweight("A");
        //把外部状态作为享元对象的方法调用参数
        fa!.Operation(--extrinsicstate);

        var fb = factory.GetFlyweight("B");
        fb!.Operation(--extrinsicstate);

        var fc = factory.GetFlyweight("C");
        fc!.Operation(--extrinsicstate);

        var fd = factory.GetFlyweight("D");
        fd!.Operation(--extrinsicstate);

        Console.WriteLine(extrinsicstate);
    }
}
