namespace Vistor;

/// <summary>
/// 访问者模式
/// </summary>
/// <remarks>
/// 访问者模式是封装一些施加于某种数据结构之上的操作。
/// 一旦这些操作需要修改的话，接受这个操作的数据结构则可以保存不变。
/// 访问者模式适用于数据结构相对稳定的系统，它把数据结构和作用于数据结构之上的操作之间的耦合度降低，使得操作集合可以相对自由地改变。
/// 数据结构的每一个节点都可以接受一个访问者的调用，此节点向访问者对象传入节点对象，而访问者对象则反过来执行节点对象的操作。
/// 这样的过程叫做“双重分派”。
/// 节点调用访问者，将它自己传入，访问者则将某算法针对此节点执行。
/// 
/// 优点：
/// 1.访问者模式使得添加新的操作变得容易。
///   如果一些操作依赖于一个复杂的结构对象的话，那么一般而言，添加新的操作会变得很复杂。
///   而使用访问者模式，增加新的操作就意味着添加一个新的访问者类。
///   因此，使得添加新的操作变得容易。
/// 2.访问者模式使得有关的行为操作集中到一个访问者对象中，而不是分散到一个个的元素类中。
///   这点类似与"中介者模式"。
/// 3.访问者模式可以访问属于不同的等级结构的成员对象，而迭代只能访问属于同一个等级结构的成员对象。
/// 
/// 缺点：
/// 1.增加新的元素类变得困难。
///   每增加一个新的元素意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中添加相应的具体操作。
/// 
/// 应用场景：
/// 1.如果系统有比较稳定的数据结构，而又有易于变化的算法时，此时可以考虑使用访问者模式。
///   因为访问者模式使得算法操作的添加比较容易。
/// 2.如果一组类中，存在着相似的操作，为了避免出现大量重复的代码，可以考虑把重复的操作封装到访问者中。（当然也可以考虑使用抽象类了）
/// 3.如果一个对象存在着一些与本身对象不相干，或关系比较弱的操作时，为了避免操作污染这个对象，则可以考虑把这些操作封装到访问者对象中。
/// </remarks>
internal class Program
{
    private static void Main(string[] args)
    {
        foreach (Element e in new ObjectStructure().Elements)
        {
            //每个元素接受访问者访问
            e.Accept(new ConcreteVistor());
        }
    }
}
